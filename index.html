<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trò Chơi Cược Xúc Xắc (Online với Phòng)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    
    <script>
        // This configuration will be populated by the environment
        if (typeof __firebase_config === 'undefined') {
            window.__firebase_config = JSON.stringify({
                apiKey: "AIzaSyCUrFw_GAv5bIGfwFfuiwCuBcjaNqFohVs",
                authDomain: "tonghaixucxac.firebaseapp.com",
                projectId: "tonghaixucxac",
                storageBucket: "tonghaixucxac.appspot.com",
                messagingSenderId: "282682257745",
                appId: "1:282682257745:web:b1d53ac3f903d95be8a370",
            });
        }
    </script>
    <style>
        body { font-family: 'Roboto', sans-serif; }
        .room-btn { transition: all 0.2s ease-in-out; }
        .room-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .bet-circle.selected-by-me { background-color: #3b82f6; color: white; border-color: #1d4ed8; }
        .bet-circle.selected-by-opponent { background-color: #ef4444; color: white; border-color: #b91c1c; }
        .bet-circle.correct-guess { animation: pulse-green 2s infinite; }
        @keyframes pulse-green { 0%, 100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.7); } 50% { box-shadow: 0 0 0 10px rgba(74, 222, 128, 0); } }
        #notification-toast { transition: opacity 0.3s, top 0.3s; z-index: 9999; }
        .danger { background-color: #ef4444 !important; color: #fff !important; }
        .dice-container {
            width: 96px;
            height: 96px;
            border: 4px solid #374151;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: white;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen p-4">
<div id="app-container" class="w-full max-w-5xl mx-auto">
    <!-- Notification Toast -->
    <div id="notification-toast" class="fixed top-5 right-5 bg-blue-600 text-white py-2 px-4 rounded-lg shadow-lg transition-opacity duration-300 z-50 opacity-0 pointer-events-none"></div>
    
    <!-- Name Entry View -->
    <div id="name-view">
        <div class="bg-white p-8 rounded-xl shadow-lg text-center">
            <h1 class="text-3xl font-bold mb-6 text-gray-700">Chào mừng đến với Cược Xúc Xắc</h1>
            <div class="mb-6">
                <label for="player-name" class="block text-lg font-medium mb-2">Nhập tên của bạn để bắt đầu</label>
                <input type="text" id="player-name" class="w-full max-w-sm mx-auto p-3 border-2 border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
            </div>
            <button id="enter-lobby-btn" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700 transition-all duration-300 shadow-md">Vào Sảnh Chờ</button>
        </div>
    </div>

    <!-- Lobby View -->
    <div id="lobby-view" class="hidden">
        <div class="bg-white p-8 rounded-xl shadow-lg">
            <div class="flex justify-between items-center mb-6">
                <h1 class="text-3xl font-bold text-gray-700">Sảnh Chờ</h1>
                <p>Xin chào, <strong id="lobby-player-name"></strong>!</p>
            </div>
            <div id="room-list" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-4"></div>
        </div>
    </div>

    <!-- Game View -->
    <div id="game-view" class="hidden">
        <div class="bg-white p-6 rounded-xl shadow-lg w-full">
            <div class="flex justify-between items-center border-b pb-4 mb-4">
                <h2 class="text-2xl font-bold text-gray-800">Phòng <span id="game-room-id"></span></h2>
                <button id="quit-game-btn" class="bg-red-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 transition">Rời Phòng</button>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4 text-center">
                <div id="player-1-info" class="p-4 bg-blue-100 rounded-lg border-2 border-blue-300"></div>
                <div id="player-2-info" class="p-4 bg-red-100 rounded-lg border-2 border-red-300"></div>
            </div>
            <div id="game-status" class="text-center text-xl font-semibold my-4 p-3 bg-yellow-100 text-yellow-800 rounded-lg"></div>
            <div id="main-game-area" class="mt-6">
                <!-- Rock Paper Scissors View -->
                <div id="rps-view" class="hidden text-center">
                    <h3 class="text-lg font-medium mb-4">Oẳn tù xì để quyết định ai đi trước!</h3>
                    <div id="rps-choices" class="flex justify-center gap-4">
                        <button data-choice="r" class="rps-choice text-5xl p-4 rounded-lg hover:bg-gray-200 transition">✊</button>
                        <button data-choice="p" class="rps-choice text-5xl p-4 rounded-lg hover:bg-gray-200 transition">✋</button>
                        <button data-choice="s" class="rps-choice text-5xl p-4 rounded-lg hover:bg-gray-200 transition">✂️</button>
                    </div>
                    <div id="rps-result-text" class="mt-4 text-2xl font-bold"></div>
                    <button id="continue-btn" class="hidden mt-4 bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700">Tiếp Tục</button>
                </div>
                <!-- Betting View -->
                <div id="betting-view" class="hidden">
                    <div id="betting-board" class="flex flex-wrap justify-center gap-3"></div>
                </div>
                <!-- 2D Dice Roll View -->
                <div id="dice-roll-view" class="hidden flex flex-col items-center justify-center min-h-[200px]">
                    <p class="text-2xl font-bold mb-4" id="rolling-text"></p>
                    <div class="flex gap-6 justify-center w-full">
                        <div id="dice1-2d" class="dice-container"></div>
                        <div id="dice2-2d" class="dice-container"></div>
                    </div>
                </div>
                <!-- Result View -->
                <div id="result-view" class="hidden text-center">
                    <h3 class="text-2xl font-bold mb-2">Kết quả là: <span id="dice-result-value" class="text-blue-600"></span></h3>
                    <p id="winner-text" class="text-xl font-semibold text-green-600 mb-4"></p>
                    <button id="play-again-btn" class="bg-green-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-green-600 transition">Chơi Lại</button>
                </div>
            </div>
        </div>
    </div>
</div>
<script type="module">
// Import Firebase services
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, collection, onSnapshot, runTransaction, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

// --- Use environment-provided variables for Firebase config and App ID ---
const firebaseConfig = JSON.parse(window.__firebase_config || '{}');
const appId = typeof __app_id !== 'undefined' ? __app_id : 'dice-game-standalone';

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

// DOM Elements
const nameView = document.getElementById('name-view');
const lobbyView = document.getElementById('lobby-view');
const gameView = document.getElementById('game-view');
const playerNameInput = document.getElementById('player-name');
const enterLobbyBtn = document.getElementById('enter-lobby-btn');
const roomList = document.getElementById('room-list');
const lobbyPlayerName = document.getElementById('lobby-player-name');
const gameRoomId = document.getElementById('game-room-id');
const quitGameBtn = document.getElementById('quit-game-btn');
const player1Info = document.getElementById('player-1-info');
const player2Info = document.getElementById('player-2-info');
const gameStatus = document.getElementById('game-status');
const rpsView = document.getElementById('rps-view');
const bettingView = document.getElementById('betting-view');
const diceRollView = document.getElementById('dice-roll-view');
const resultView = document.getElementById('result-view');
const playAgainBtn = document.getElementById('play-again-btn');
const rpsChoices = document.getElementById('rps-choices');
const rpsResultText = document.getElementById('rps-result-text');
const continueBtn = document.getElementById('continue-btn');
const notificationToast = document.getElementById('notification-toast');

// Global state variables
let localPlayerName = '';
let currentRoomId = null;
let myPlayerIndex = null;
let gameState = {};
let lobbyUnsubscribe = null;
let gameUnsubscribe = null;
let userId;
let joinTimeout = null;
let isRollingFlag = false;
let rollAnimationInterval = null; // Variable for the animation interval

// Firestore collection path
const roomsCollectionPath = `/artifacts/${appId}/public/data/dice-game-rooms`;

// --- UTILITY FUNCTIONS ---
function showNotification(message, danger = false) {
    notificationToast.textContent = message;
    notificationToast.classList.remove('opacity-0');
    if (danger) notificationToast.classList.add('danger');
    else notificationToast.classList.remove('danger');
    setTimeout(() => notificationToast.classList.add('opacity-0'), 4000);
}

function showView(view) {
    [nameView, lobbyView, gameView].forEach(v => v.classList.add('hidden'));
    view.classList.remove('hidden');
}

// --- 2D DICE LOGIC ---
function draw2DDice(containerId, value) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = ''; 

    const pipsLayouts = {
        1: [[50, 50]],
        2: [[25, 25], [75, 75]],
        3: [[25, 25], [50, 50], [75, 75]],
        4: [[25, 25], [75, 25], [25, 75], [75, 75]],
        5: [[25, 25], [75, 25], [50, 50], [25, 75], [75, 75]],
        6: [[25, 25], [75, 25], [25, 50], [75, 50], [25, 75], [75, 75]]
    };

    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('viewBox', '0 0 100 100');
    
    const pips = pipsLayouts[value] || [];
    pips.forEach(pip => {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', pip[0]);
        circle.setAttribute('cy', pip[1]);
        circle.setAttribute('r', 8);
        circle.setAttribute('fill', 'black');
        svg.appendChild(circle);
    });

    container.appendChild(svg);
}


// --- NAVIGATION & ROOM MANAGEMENT ---
async function goToLobby() {
    if (joinTimeout) clearTimeout(joinTimeout);
    if (gameUnsubscribe) gameUnsubscribe();
    gameUnsubscribe = null; currentRoomId = null; myPlayerIndex = null;
    lobbyPlayerName.textContent = localPlayerName;
    showView(lobbyView);
    renderLobby({});
    listenToLobby();
}

async function leaveRoom() {
    if (!currentRoomId || !userId) return goToLobby();
    const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
    try {
        await runTransaction(db, async (transaction) => {
            const roomDoc = await transaction.get(roomRef);
            if (!roomDoc.exists()) return;
            let players = [...(roomDoc.data().players || [null, null])];
            const idx = players.findIndex(p => p && p.id === userId);
            if (idx !== -1) players[idx] = null;
            const stillPlayers = players.filter(p => p && p.id);
            if (stillPlayers.length === 0) {
                transaction.delete(roomRef);
            } else {
                transaction.set(roomRef, { players: [stillPlayers[0] || null, null], playerCount: stillPlayers.length, status: 'waiting' }, { merge: true });
            }
        });
    } catch (error) {
        console.error("Error leaving room:", error);
        showNotification("Lỗi khi rời phòng.");
    } finally {
        goToLobby();
    }
}
quitGameBtn.addEventListener('click', leaveRoom);

// --- LOBBY LOGIC ---
function listenToLobby() {
    if (lobbyUnsubscribe) lobbyUnsubscribe();
    const roomsRef = collection(db, roomsCollectionPath);
    lobbyUnsubscribe = onSnapshot(roomsRef, (snapshot) => {
        const roomsData = {};
        snapshot.forEach(doc => { const room = doc.data(); if(room.id) roomsData[room.id] = room; });
        renderLobby(roomsData);
    });
}

function renderLobby(roomsData) {
    roomList.innerHTML = '';
    for (let i = 1; i <= 30; i++) {
        const room = roomsData[i];
        const btn = document.createElement('button');
        btn.className = 'room-btn p-4 border rounded-lg shadow-sm';
        let text = '', statusClass = '';
        if (room && room.playerCount > 0) {
            text = `${room.playerCount} / 2`;
            statusClass = room.playerCount === 1 ? 'bg-yellow-100 border-yellow-300' : 'bg-red-200 border-red-400 text-gray-500';
            btn.disabled = room.playerCount === 2;
        } else {
            text = 'Trống';
            statusClass = 'bg-green-100 border-green-300 hover:bg-green-200';
            btn.disabled = false;
        }
        btn.innerHTML = `<div class="font-bold text-lg">Phòng ${i}</div><div class="text-sm">${text}</div>`;
        btn.classList.add(...statusClass.split(' '));
        btn.dataset.roomId = i;
        btn.onclick = () => joinRoom(i);
        roomList.appendChild(btn);
    }
}

async function joinRoom(roomId) {
    if (!userId) { showNotification("Đang xác thực, vui lòng đợi..."); return; }
    const roomRef = doc(db, roomsCollectionPath, `room-${roomId}`);
    try {
        showView(gameView);
        gameRoomId.textContent = roomId;
        gameStatus.textContent = 'Đang tham gia phòng...';
        joinTimeout = setTimeout(() => { if (myPlayerIndex === null) { showNotification("Không thể vào phòng. Vui lòng thử lại!", true); goToLobby(); } }, 10000);
        await runTransaction(db, async (transaction) => {
            const roomDoc = await transaction.get(roomRef);
            if (!roomDoc.exists()) {
                const newRoomData = { id: roomId, players: [{ id: userId, name: localPlayerName, score: 0, rpsChoice: null, bet: null, wantsRematch: false }, null], playerCount: 1, status: 'waiting' };
                transaction.set(roomRef, newRoomData);
                myPlayerIndex = 0;
            } else {
                const roomData = roomDoc.data();
                let players = [...(roomData.players || [null, null])];
                const slot = players.findIndex(p => !p || !p.id);
                if (slot === -1) throw new Error("Phòng đã đầy!");
                players[slot] = { id: userId, name: localPlayerName, score: 0, rpsChoice: null, bet: null, wantsRematch: false };
                const playerCount = players.filter(p => p && p.id).length;
                transaction.set(roomRef, { players, playerCount, status: playerCount === 2 ? 'rps' : 'waiting' }, { merge: true });
                myPlayerIndex = slot;
            }
        });
        if(lobbyUnsubscribe) lobbyUnsubscribe();
        currentRoomId = roomId;
        listenToGame(roomId);
    } catch (e) {
        showNotification(e.message || "Lỗi không xác định", true);
        goToLobby();
    }
}

// --- GAME STATE LISTENER & UI UPDATES ---
function listenToGame(roomId) {
    if (gameUnsubscribe) gameUnsubscribe();
    const roomRef = doc(db, roomsCollectionPath, `room-${roomId}`);
    gameUnsubscribe = onSnapshot(roomRef, (docSnap) => {
        if (!docSnap.exists()) { showNotification("Chủ phòng đã rời đi. Quay về sảnh chờ."); goToLobby(); return; }
        
        gameState = JSON.parse(JSON.stringify(docSnap.data()));

        if (myPlayerIndex === null || myPlayerIndex === -1) {
            myPlayerIndex = (gameState.players || []).findIndex(p => p && p.id === userId);
        }
        updateGameUI();
    });
}

function updateGameUI() {
    if (!gameState || !gameState.players) { gameStatus.textContent = 'Đang tải dữ liệu phòng...'; return; }
    if (myPlayerIndex === -1 || myPlayerIndex === null) { gameStatus.textContent = 'Đang đồng bộ...'; return; }
    if (joinTimeout) clearTimeout(joinTimeout);
    const me = gameState.players[myPlayerIndex];
    const opponent = gameState.players[1 - myPlayerIndex];
    gameRoomId.textContent = currentRoomId;
    const renderPlayerBox = (el, player, isMe) => {
        if (!player) { el.innerHTML = `<h3 class="font-bold text-lg">Đang chờ...</h3>`; return; }
        const rpsMap = { r: '✊', p: '✋', s: '✂️' };
        let rpsDisplay = '';
        if (player.rpsChoice && gameState.status === 'rps') {
            rpsDisplay = (gameState.players[0]?.rpsChoice && gameState.players[1]?.rpsChoice)
                ? `<p class="mt-1">Ra: <span class="text-2xl">${rpsMap[player.rpsChoice]}</span></p>`
                : `<p class="mt-1">Ra: <span class="text-xl font-bold text-gray-500">Đã chọn</span></p>`;
        }
        const displayName = player.name ? (isMe ? `${player.name} (Bạn)` : player.name) : (isMe ? "Bạn" : "Đối thủ");
        el.innerHTML = `<h3 class="text-lg font-bold">${displayName}</h3><p class="text-2xl font-black text-indigo-600">${player.score || 0} Điểm</p>${player.bet ? `<p class="mt-1">Đã cược: <span class="font-bold text-xl">${player.bet}</span></p>` : ''}${rpsDisplay}`;
    };
    renderPlayerBox(player1Info, gameState.players[0], myPlayerIndex === 0);
    renderPlayerBox(player2Info, gameState.players[1], myPlayerIndex === 1);
    [rpsView, bettingView, diceRollView, resultView].forEach(v => v.classList.add('hidden'));
    switch(gameState.status) {
        case 'waiting': gameStatus.textContent = 'Đang chờ người chơi thứ hai...'; break;
        case 'rps': handleRPSUI(me, opponent); break;
        case 'betting': handleBettingUI(me, opponent); break;
        case 'rolling': handleRollingUI(); break;
        case 'results': handleResultUI(me); break;
    }
    if (gameState.status === 'results' && me?.wantsRematch && opponent?.wantsRematch) {
        checkAndResetForRematch();
    }
}

// --- GAME LOGIC & STATE UPDATES ---
async function updatePlayerState(key, value) {
    if (typeof myPlayerIndex !== 'number' || myPlayerIndex < 0) { showNotification('Lỗi xác định người chơi.', true); return; }
    const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
    try {
        await runTransaction(db, async (transaction) => {
            const roomDoc = await transaction.get(roomRef);
            if (!roomDoc.exists()) return;
            let players = [...(roomDoc.data().players || [null, null])];
            if (!players[myPlayerIndex]) players[myPlayerIndex] = {};
            players[myPlayerIndex][key] = value;
            transaction.set(roomRef, { players }, { merge: true });
        });
    } catch (error) { console.error("Error updating player state:", error); showNotification("Có lỗi khi cập nhật trạng thái.", true); }
}

// --- RPS Stage ---
function handleRPSUI(me, opponent) {
    rpsView.classList.remove('hidden');
    rpsResultText.textContent = '';
    continueBtn.classList.add('hidden');
    rpsChoices.classList.remove('hidden');
    const rpsMap = { r: 'Búa ✊', p: 'Bao ✋', s: 'Kéo ✂️' };
    if (me?.rpsChoice && opponent?.rpsChoice) {
        rpsChoices.classList.add('hidden');
        const winnerId = determineRPSWinner();
        if (winnerId === -1) {
            rpsResultText.innerHTML = `Hòa! Cả hai cùng ra ${rpsMap[me.rpsChoice]}. Chơi lại!`;
            if (myPlayerIndex === 0) continueBtn.classList.remove('hidden'); else gameStatus.textContent = 'Hòa! Đang chờ chủ phòng chơi lại...';
        } else {
            const winnerName = gameState.players[winnerId]?.name || `Người chơi ${winnerId + 1}`;
            rpsResultText.innerHTML = `${gameState.players[0]?.name} ra ${rpsMap[gameState.players[0].rpsChoice]}, ${gameState.players[1]?.name} ra ${rpsMap[gameState.players[1].rpsChoice]}. <br> <span class="text-green-600">${winnerName} thắng và đi trước!</span>`;
            if (myPlayerIndex === winnerId) continueBtn.classList.remove('hidden'); else gameStatus.textContent = `Đang chờ ${winnerName} tiếp tục...`;
        }
    } else if (me?.rpsChoice) {
        gameStatus.textContent = `Đã chọn. Đang chờ ${opponent?.name || 'đối thủ'}...`;
        rpsChoices.classList.add('hidden');
    } else {
        gameStatus.textContent = 'Đến lượt bạn! Hãy ra Kéo, Búa, hoặc Bao.';
    }
}

rpsChoices.addEventListener('click', (e) => { const choice = e.target.closest('.rps-choice')?.dataset.choice; if (choice) updatePlayerState('rpsChoice', choice); });

continueBtn.addEventListener('click', async () => {
    const winner = determineRPSWinner();
    const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
    await runTransaction(db, async (transaction) => {
        if (winner === -1) {
            if (myPlayerIndex === 0) {
                const roomDoc = await transaction.get(roomRef);
                if (!roomDoc.exists()) return;
                let players = [...(roomDoc.data().players || [null, null])];
                if(players[0]) players[0].rpsChoice = null;
                if(players[1]) players[1].rpsChoice = null;
                transaction.set(roomRef, { players }, { merge: true });
            }
        } else {
            if (myPlayerIndex === winner) {
                transaction.set(roomRef, { status: 'betting', turn: winner, rpsWinner: winner }, { merge: true });
            }
        }
    });
});

function determineRPSWinner() {
    const p1c = gameState.players[0]?.rpsChoice, p2c = gameState.players[1]?.rpsChoice;
    if (!p1c || !p2c) return null;
    if (p1c === p2c) return -1;
    if ((p1c === 'r' && p2c === 's') || (p1c === 's' && p2c === 'p') || (p1c === 'p' && p2c === 'r')) return 0;
    return 1;
}

// --- Betting Stage ---
async function placeBet(number) {
    const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
    await runTransaction(db, async (transaction) => {
        const roomDoc = await transaction.get(roomRef);
        if (!roomDoc.exists()) return;
        let players = [...(roomDoc.data().players || [null, null])];
        if(players[myPlayerIndex]) players[myPlayerIndex].bet = number;
        const opponentIndex = 1 - myPlayerIndex;
        const nextStatus = (players[opponentIndex]?.bet !== null && players[opponentIndex]?.bet !== undefined) ? 'rolling' : 'betting';
        const nextTurn = (nextStatus === 'betting') ? opponentIndex : null;
        transaction.set(roomRef, { players, status: nextStatus, turn: nextTurn }, { merge: true });
    });
}

function handleBettingUI(me, opponent) {
    bettingView.classList.remove('hidden');
    renderBettingBoard();
    gameStatus.textContent = (gameState.turn === myPlayerIndex) ? 'Đến lượt bạn! Hãy chọn một số để cược.' : `Đang chờ ${opponent?.name || 'đối thủ'} đặt cược...`;
}

function renderBettingBoard() {
    const board = document.getElementById('betting-board');
    board.innerHTML = '';
    const me = gameState.players?.[myPlayerIndex];
    const opponent = gameState.players?.[1 - myPlayerIndex];
    const myTurn = gameState.status === 'betting' && gameState.turn === myPlayerIndex;
    for (let i = 2; i <= 12; i++) {
        const circle = document.createElement('button');
        circle.textContent = i;
        const opponentBet = opponent?.bet;
        let classes = 'bet-circle w-16 h-16 rounded-full flex items-center justify-center text-2xl font-bold border-4 transition ';
        if (i === me?.bet) classes += 'selected-by-me ';
        else if (i === opponentBet) classes += 'selected-by-opponent ';
        else classes += 'bg-white border-gray-300 ';
        const canBet = myTurn && !me?.bet && i !== opponentBet;
        classes += canBet ? 'hover:bg-blue-200 cursor-pointer' : 'opacity-70 cursor-not-allowed';
        circle.disabled = !canBet;
        if (gameState.status === 'results' && i === gameState.diceResult) classes += ' correct-guess border-green-400';
        circle.className = classes;
        if (!circle.disabled) circle.onclick = () => placeBet(i);
        board.appendChild(circle);
    }
}

// --- Rolling & Results Stage ---
function handleRollingUI() {
    if (isRollingFlag) return; 
    isRollingFlag = true;

    gameStatus.textContent = 'Tất cả đã cược! Chuẩn bị xem kết quả!';
    diceRollView.classList.remove('hidden');
    document.getElementById('rolling-text').textContent = "Đang tung xúc xắc...";
    
    if (rollAnimationInterval) clearInterval(rollAnimationInterval);
    rollAnimationInterval = setInterval(() => {
        draw2DDice('dice1-2d', Math.floor(Math.random() * 6) + 1);
        draw2DDice('dice2-2d', Math.floor(Math.random() * 6) + 1);
    }, 100);

    if (myPlayerIndex === 0) {
        setTimeout(rollDice, 2500);
    }
}

async function rollDice() {
    if (myPlayerIndex !== 0) return;
    const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
    try {
        await runTransaction(db, async (transaction) => {
            const roomDoc = await transaction.get(roomRef);
            if (!roomDoc.exists()) return;
            
            if (roomDoc.data().status !== 'rolling') {
                console.warn("RollDice aborted: game status is not 'rolling'.");
                return;
            }

            const players = JSON.parse(JSON.stringify(roomDoc.data().players || [null, null]));
            const die1 = Math.floor(Math.random() * 6) + 1;
            const die2 = Math.floor(Math.random() * 6) + 1;
            const totalResult = die1 + die2;
            const p1Won = players[0]?.bet === totalResult;
            const p2Won = players[1]?.bet === totalResult;
            if (players[0]) players[0].score = (players[0].score || 0) + (p1Won ? 1 : 0);
            if (players[1]) players[1].score = (players[1].score || 0) + (p2Won ? 1 : 0);
            let roundWinner = null;
            if (p1Won && p2Won) roundWinner = -1;
            else if (p1Won) roundWinner = 0;
            else if (p2Won) roundWinner = 1;
            const updatePayload = { players, diceFaces: [die1, die2], diceResult: totalResult, status: 'results', roundWinner };
            transaction.set(roomRef, updatePayload, { merge: true });
        });
    } catch (error) { console.error("Error in rollDice transaction:", error); showNotification("Đã có lỗi xảy ra khi tung xúc xắc!", true); }
}

function handleResultUI(me) {
    if (rollAnimationInterval) {
        clearInterval(rollAnimationInterval);
        rollAnimationInterval = null;
    }
    isRollingFlag = false; 

    gameStatus.textContent = 'Vòng chơi kết thúc!';
    resultView.classList.remove('hidden');
    bettingView.classList.remove('hidden'); 
    renderBettingBoard();
    document.getElementById('dice-result-value').textContent = gameState.diceResult;
    if (gameState.diceFaces) {
        diceRollView.classList.remove('hidden');
        document.getElementById('rolling-text').textContent = "Kết quả xúc xắc:";
        draw2DDice('dice1-2d', gameState.diceFaces[0]);
        draw2DDice('dice2-2d', gameState.diceFaces[1]);
    }
    const winnerText = document.getElementById('winner-text');
    const winnerId = gameState.roundWinner;
    if (winnerId === null) winnerText.textContent = 'Không ai đoán trúng!';
    else if (winnerId === -1) winnerText.textContent = 'Cả hai người chơi đều đoán trúng! Mỗi người 1 điểm.';
    else winnerText.textContent = `${gameState.players[winnerId]?.name || 'Người chơi'} đã thắng vòng này và được 1 điểm!`;
    playAgainBtn.textContent = me?.wantsRematch ? 'Đang chờ đối thủ...' : 'Chơi Lại';
    playAgainBtn.disabled = me?.wantsRematch;
}

// --- Rematch Logic ---
playAgainBtn.addEventListener('click', () => updatePlayerState('wantsRematch', true));

async function checkAndResetForRematch() {
    if (
        gameState.status === 'results' &&
        gameState.players[0]?.wantsRematch &&
        gameState.players[1]?.wantsRematch &&
        myPlayerIndex === 0
    ) {
        const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
        await runTransaction(db, async (transaction) => {
            const roomDoc = await transaction.get(roomRef);
            if (!roomDoc.exists()) return;
            
            const currentData = roomDoc.data();
            
            const newGameState = {
                id: currentData.id,
                playerCount: currentData.playerCount,
                players: JSON.parse(JSON.stringify(currentData.players)),
                status: 'betting',
                turn: (currentData.roundWinner !== null && currentData.roundWinner !== -1) ? currentData.roundWinner : currentData.rpsWinner,
                rpsWinner: currentData.rpsWinner
            };

            if(newGameState.players[0]) { 
                newGameState.players[0].bet = null; 
                newGameState.players[0].wantsRematch = false; 
                newGameState.players[0].rpsChoice = null; 
            }
            if(newGameState.players[1]) { 
                newGameState.players[1].bet = null; 
                newGameState.players[1].wantsRematch = false; 
                newGameState.players[1].rpsChoice = null; 
            }
            
            transaction.set(roomRef, newGameState);
        });
    }
}


// --- APP INITIALIZATION ---
enterLobbyBtn.addEventListener('click', () => {
    localPlayerName = playerNameInput.value.trim();
    if (!localPlayerName) { showNotification("Vui lòng nhập tên của bạn.", true); return; }
    localStorage.setItem('dice_player_name', localPlayerName);
    goToLobby();
});

(async () => {
    const savedName = localStorage.getItem('dice_player_name');
    if (savedName) playerNameInput.value = savedName;
    enterLobbyBtn.disabled = true;
    enterLobbyBtn.textContent = 'Đang kết nối...';
    enterLobbyBtn.classList.add('bg-gray-400', 'cursor-not-allowed');
    enterLobbyBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
    onAuthStateChanged(auth, async (user) => {
        if (user) {
            userId = user.uid;
            enterLobbyBtn.disabled = false;
            enterLobbyBtn.textContent = 'Vào Sảnh Chờ';
            enterLobbyBtn.classList.remove('bg-gray-400', 'cursor-not-allowed');
            enterLobbyBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
        } else {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Authentication Error:", error);
                showNotification("Không thể kết nối. Vui lòng làm mới trang.", true);
                enterLobbyBtn.textContent = 'Lỗi kết nối';
            }
        }
    });
    showView(nameView);
})();
</script>
</body>
</html>

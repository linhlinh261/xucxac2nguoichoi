<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trò Chơi Cược Xúc Xắc 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- 3D Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script>
        // This is a placeholder for OrbitControls, as we can't load it from a separate file here.
        // In a real environment, you would load this from a CDN.
        // For this example, the camera is fixed.
    </script>
    <!-- Firebase -->
    <script>
        if (typeof __firebase_config === 'undefined') {
          window.__firebase_config = JSON.stringify({
              apiKey: "AIzaSyCUrFw_GAv5bIGfwFfuiwCuBcjaNqFohVs",
              authDomain: "tonghaixucxac.firebaseapp.com",
              projectId: "tonghaixucxac",
              storageBucket: "tonghaixucxac.firebasestorage.app",
              messagingSenderId: "282682257745",
              appId: "1:282682257745:web:b1d53ac3f903d95be8a370",
          });
        }
    </script>
    <style>
        body { font-family: 'Roboto', sans-serif; overflow: hidden; }
        .room-btn { transition: all 0.2s ease-in-out; }
        .room-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .bet-circle.selected-by-me { background-color: #3b82f6; color: white; border-color: #1d4ed8; }
        .bet-circle.selected-by-opponent { background-color: #ef4444; color: white; border-color: #b91c1c; }
        .bet-circle.correct-guess { animation: pulse-green 2s infinite; }
        @keyframes pulse-green { 0%, 100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.7); } 50% { box-shadow: 0 0 0 10px rgba(74, 222, 128, 0); } }
        #notification-toast.danger { background-color: #ef4444; }
        #dice-roll-canvas {
            display: block;
            width: 100%;
            height: 300px; /* Or adjust as needed */
            background-color: #f0f0f0;
            border-radius: 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen p-4">

    <div id="app-container" class="w-full max-w-5xl mx-auto">
        <!-- Notification Toast -->
        <div id="notification-toast" class="fixed top-5 right-5 bg-blue-600 text-white py-2 px-4 rounded-lg shadow-lg transition-opacity duration-300 z-50 opacity-0 pointer-events-none"></div>

        <!-- Name View -->
        <div id="name-view">
            <div class="bg-white p-8 rounded-xl shadow-lg text-center">
                <h1 class="text-3xl font-bold mb-6 text-gray-700">Chào mừng đến với Cược Xúc Xắc</h1>
                <div class="mb-6">
                    <label for="player-name" class="block text-lg font-medium mb-2">Nhập tên của bạn để bắt đầu</label>
                    <input type="text" id="player-name" class="w-full max-w-sm mx-auto p-3 border-2 border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                </div>
                <button id="enter-lobby-btn" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700 transition-all duration-300 shadow-md">Vào Sảnh Chờ</button>
            </div>
        </div>

        <!-- Lobby View -->
        <div id="lobby-view" class="hidden">
            <div class="bg-white p-8 rounded-xl shadow-lg">
                <div class="flex justify-between items-center mb-6">
                    <h1 class="text-3xl font-bold text-gray-700">Sảnh Chờ</h1>
                    <p>Xin chào, <strong id="lobby-player-name"></strong>!</p>
                </div>
                <div id="room-list" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-4">
                    <!-- Room buttons will be generated here -->
                </div>
            </div>
        </div>
        
        <!-- Game View -->
        <div id="game-view" class="hidden">
             <div class="bg-white p-6 rounded-xl shadow-lg w-full">
                <div class="flex justify-between items-center border-b pb-4 mb-4">
                    <h2 class="text-2xl font-bold text-gray-800">Phòng <span id="game-room-id"></span></h2>
                    <button id="quit-game-btn" class="bg-red-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 transition">Rời Phòng</button>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4 text-center">
                    <div id="player-1-info" class="p-4 bg-blue-100 rounded-lg border-2 border-blue-300"></div>
                    <div id="player-2-info" class="p-4 bg-red-100 rounded-lg border-2 border-red-300"></div>
                </div>
                <div id="game-status" class="text-center text-xl font-semibold my-4 p-3 bg-yellow-100 text-yellow-800 rounded-lg"></div>
                <div id="main-game-area" class="mt-6">
                     <div id="rps-view" class="hidden text-center">
                        <h3 class="text-lg font-medium mb-4">Oẳn tù xì để quyết định ai đi trước!</h3>
                        <div id="rps-choices" class="flex justify-center gap-4">
                            <button data-choice="r" class="rps-choice text-5xl p-4 rounded-lg hover:bg-gray-200 transition">✊</button>
                            <button data-choice="p" class="rps-choice text-5xl p-4 rounded-lg hover:bg-gray-200 transition">✋</button>
                            <button data-choice="s" class="rps-choice text-5xl p-4 rounded-lg hover:bg-gray-200 transition">✂️</button>
                        </div>
                        <div id="rps-result-text" class="mt-4 text-2xl font-bold"></div>
                        <button id="continue-btn" class="hidden mt-4 bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700">Tiếp Tục</button>
                    </div>
                    <div id="betting-view" class="hidden">
                        <div id="betting-board" class="flex flex-wrap justify-center gap-3"></div>
                    </div>
                    <div id="dice-roll-view" class="hidden flex flex-col items-center justify-center min-h-[350px]">
                        <p class="text-2xl font-bold mb-4" id="rolling-text"></p>
                        <canvas id="dice-roll-canvas"></canvas>
                    </div>
                    <div id="result-view" class="hidden text-center">
                        <h3 class="text-2xl font-bold mb-2">Kết quả là: <span id="dice-result-value" class="text-blue-600"></span></h3>
                        <p id="winner-text" class="text-xl font-semibold text-green-600 mb-4"></p>
                        <button id="play-again-btn" class="bg-green-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-green-600 transition">Chơi Lại</button>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, collection, onSnapshot, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- Firebase Initialization ---
        const firebaseConfig = JSON.parse(window.__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- UI Elements ---
        const nameView = document.getElementById('name-view');
        const lobbyView = document.getElementById('lobby-view');
        const gameView = document.getElementById('game-view');
        const playerNameInput = document.getElementById('player-name');
        const enterLobbyBtn = document.getElementById('enter-lobby-btn');
        const roomList = document.getElementById('room-list');
        const lobbyPlayerName = document.getElementById('lobby-player-name');
        const gameRoomId = document.getElementById('game-room-id');
        const quitGameBtn = document.getElementById('quit-game-btn');
        const player1Info = document.getElementById('player-1-info');
        const player2Info = document.getElementById('player-2-info');
        const gameStatus = document.getElementById('game-status');
        const rpsView = document.getElementById('rps-view');
        const bettingView = document.getElementById('betting-view');
        const diceRollView = document.getElementById('dice-roll-view');
        const resultView = document.getElementById('result-view');
        const playAgainBtn = document.getElementById('play-again-btn');
        const rpsChoices = document.getElementById('rps-choices');
        const rpsResultText = document.getElementById('rps-result-text');
        const continueBtn = document.getElementById('continue-btn');
        const notificationToast = document.getElementById('notification-toast');

        // --- App State ---
        let localPlayerName = '';
        let currentRoomId = null;
        let myPlayerIndex = null;
        let gameState = {};
        let lobbyUnsubscribe = null;
        let gameUnsubscribe = null;
        let userId;
        let joinTimeout = null;

        // --- Constants ---
        const appId = 'dice-game-2024';
        const roomsCollectionPath = `/artifacts/${appId}/public/data/dice-game-rooms-v7`;
        
        // --- Utility ---
        function showNotification(message, danger = false) {
            notificationToast.textContent = message;
            notificationToast.classList.remove('opacity-0');
            if (danger) notificationToast.classList.add('danger');
            else notificationToast.classList.remove('danger');
            setTimeout(() => notificationToast.classList.add('opacity-0'), 4000);
        }

        // --- Navigation & State Management ---
        function showView(view) {
            [nameView, lobbyView, gameView].forEach(v => v.classList.add('hidden'));
            view.classList.remove('hidden');
        }

        async function goToLobby() {
            if (joinTimeout) clearTimeout(joinTimeout);
            if (gameUnsubscribe) gameUnsubscribe();
            gameUnsubscribe = null;
            currentRoomId = null;
            myPlayerIndex = null;
            lobbyPlayerName.textContent = localPlayerName;
            showView(lobbyView);
            renderLobby({});
            listenToLobby();
        }

        async function leaveRoom() {
            if (!currentRoomId || !userId) return goToLobby();
            const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) return;

                    const roomData = roomDoc.data();
                    if (roomData.playerCount <= 1) {
                         transaction.delete(roomRef);
                         return;
                    }

                    const leavingPlayerIndex = roomData.players.findIndex(p => p && p.id === userId);
                    if(leavingPlayerIndex === -1) return;

                    const updatedPlayers = [...roomData.players];
                    updatedPlayers[leavingPlayerIndex] = null;
                    
                    const updatedRoomData = {
                        ...roomData,
                        players: updatedPlayers,
                        playerCount: 1,
                        status: 'waiting'
                    };
                    transaction.set(roomRef, updatedRoomData);
                });
            } catch (error) {
                showNotification("Lỗi khi rời phòng.", true);
            } finally {
                goToLobby();
            }
        }
        quitGameBtn.addEventListener('click', leaveRoom);

        // --- Lobby Logic ---
        function listenToLobby() {
            if (lobbyUnsubscribe) lobbyUnsubscribe();
            const roomsRef = collection(db, roomsCollectionPath);
            lobbyUnsubscribe = onSnapshot(roomsRef, (snapshot) => {
                const roomsData = {};
                snapshot.forEach(doc => {
                    const room = doc.data();
                    if(room.id) roomsData[room.id] = room;
                });
                renderLobby(roomsData);
            });
        }

        function renderLobby(roomsData) {
            roomList.innerHTML = '';
            for (let i = 1; i <= 30; i++) {
                const room = roomsData[i];
                const btn = document.createElement('button');
                btn.className = 'room-btn p-4 border rounded-lg shadow-sm';
                let text = '';
                let statusClass = '';
                if (room && room.playerCount > 0) {
                    text = `${room.playerCount} / 2`;
                    if (room.playerCount === 1) {
                        statusClass = 'bg-yellow-100 border-yellow-300';
                        btn.disabled = false;
                    } else {
                        statusClass = 'bg-red-200 border-red-400 text-gray-500';
                        btn.disabled = true;
                    }
                } else {
                    text = 'Trống';
                    statusClass = 'bg-green-100 border-green-300 hover:bg-green-200';
                    btn.disabled = false;
                }
                btn.innerHTML = `<div class="font-bold text-lg">Phòng ${i}</div><div class="text-sm">${text}</div>`;
                btn.classList.add(...statusClass.split(' '));
                btn.dataset.roomId = i;
                btn.onclick = () => joinRoom(i);
                roomList.appendChild(btn);
            }
        }

        async function joinRoom(roomId) {
            if (!userId || !localPlayerName) {
                showNotification("Vui lòng nhập tên và đợi xác thực.", true);
                return;
            }

            const roomRef = doc(db, roomsCollectionPath, `room-${roomId}`);
            try {
                showView(gameView);
                gameRoomId.textContent = roomId;
                gameStatus.textContent = 'Đang tham gia phòng...';
                
                joinTimeout = setTimeout(() => {
                    if (myPlayerIndex === null) {
                        showNotification("Không thể vào phòng. Vui lòng thử lại!", true);
                        goToLobby();
                    }
                }, 10000);

                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    const newPlayer = { id: userId, name: localPlayerName, score: 0, rpsChoice: null, bet: null, wantsRematch: false };

                    if (!roomDoc.exists()) {
                        const newRoomState = {
                            id: roomId,
                            players: [newPlayer, null],
                            playerCount: 1,
                            status: 'waiting',
                        };
                        transaction.set(roomRef, newRoomState);
                    } else {
                        const existingData = roomDoc.data();
                        if (existingData.playerCount >= 2) throw new Error("Phòng đã đầy!");
                        
                        const players = [...existingData.players];
                        const emptySlot = players.findIndex(p => p === null);
                        if (emptySlot === -1) throw new Error("Phòng đầy nhưng playerCount không chính xác.");
                        
                        players[emptySlot] = newPlayer;

                        const updatedRoomState = {
                           id: existingData.id,
                           players: players,
                           playerCount: 2,
                           status: 'rps'
                        };
                        transaction.set(roomRef, updatedRoomState);
                    }
                });

                if(lobbyUnsubscribe) lobbyUnsubscribe();
                currentRoomId = roomId;
                listenToGame(roomId);

            } catch (e) {
                showNotification(e.message, true);
                goToLobby(); 
            }
        }

        // --- Game Logic & Validation ---
        function listenToGame(roomId) {
            if (gameUnsubscribe) gameUnsubscribe();
            const roomRef = doc(db, roomsCollectionPath, `room-${roomId}`);
            gameUnsubscribe = onSnapshot(roomRef, (docSnap) => {
                if (!docSnap.exists()) {
                    showNotification("Chủ phòng đã rời đi. Quay về sảnh chờ.");
                    goToLobby();
                    return;
                }
                gameState = docSnap.data();
                if (!Array.isArray(gameState.players)) {
                    const playersMap = gameState.players;
                    gameState.players = [playersMap['0'] || null, playersMap['1'] || null];
                }
                updateGameUI();
            });
        }

       function updateGameUI() {
            if (!gameState || !gameState.players) {
                gameStatus.textContent = 'Đang tải dữ liệu phòng...';
                return;
            }
            
            myPlayerIndex = gameState.players.findIndex(p => p && p.id === userId);
            
            if (myPlayerIndex === -1) {
                gameStatus.textContent = 'Đang đồng bộ...';
                [rpsView, bettingView, diceRollView, resultView].forEach(v => v.classList.add('hidden'));
                player1Info.innerHTML = `<h3 class="font-bold text-lg">Đang tải...</h3>`;
                player2Info.innerHTML = `<h3 class="font-bold text-lg">Đang tải...</h3>`;
                return;
            }
            
            if (joinTimeout) {
                clearTimeout(joinTimeout);
                joinTimeout = null;
            }

            const opponentIndex = 1 - myPlayerIndex;
            const me = gameState.players[myPlayerIndex];
            const opponent = gameState.players[opponentIndex];

            gameRoomId.textContent = currentRoomId;
            function renderPlayerBox(el, player, isMe) {
                if (!player) {
                    el.innerHTML = `<h3 class="font-bold text-lg">Đang chờ...</h3>`;
                    return;
                }
                const rpsMap = { r: '✊', p: '✋', s: '✂️' };
                let rpsDisplay = '';
                if (player.rpsChoice && gameState.status === 'rps') {
                    if (gameState.players[0]?.rpsChoice && gameState.players[1]?.rpsChoice) {
                        rpsDisplay = `<p class="mt-1">Ra: <span class="text-2xl">${rpsMap[player.rpsChoice]}</span></p>`;
                    } else {
                        rpsDisplay = `<p class="mt-1">Ra: <span class="text-xl font-bold text-gray-500">Đã chọn</span></p>`;
                    }
                }
                const displayName = player.name ? (isMe ? player.name + " (Bạn)" : player.name) : (isMe ? "Bạn" : "Người chơi");
                el.innerHTML = `
                    <h3 class="text-lg font-bold">${displayName}</h3>
                    <p class="text-2xl font-black text-indigo-600">${Number.isFinite(player.score) ? player.score : 0} Điểm</p>
                    ${player.bet ? `<p class="mt-1">Đã cược: <span class="font-bold text-xl">${player.bet}</span></p>` : ''}
                    ${rpsDisplay}
                `;
            }
            renderPlayerBox(player1Info, gameState.players[0], myPlayerIndex === 0);
            renderPlayerBox(player2Info, gameState.players[1], myPlayerIndex === 1);

            [rpsView, bettingView, diceRollView, resultView].forEach(v => v.classList.add('hidden'));

            switch(gameState.status) {
                case 'waiting':
                    gameStatus.textContent = 'Đang chờ người chơi thứ hai...';
                    break;
                case 'rps': handleRPSUI(me, opponent); break;
                case 'betting': handleBettingUI(me, opponent); break;
                case 'rolling': handleRollingUI(); break;
                case 'results': handleResultUI(me); break;
            }
            if (gameState.status === 'results' && me?.wantsRematch && opponent?.wantsRematch) {
                 checkAndResetForRematch();
             }
        }
        
        function handleRPSUI(me, opponent) {
             rpsView.classList.remove('hidden');
             rpsResultText.textContent = '';
             continueBtn.classList.add('hidden');
             rpsChoices.classList.remove('hidden');
             const rpsMap = { r: 'Búa ✊', p: 'Bao ✋', s: 'Kéo ✂️' };
             if (me?.rpsChoice && opponent?.rpsChoice) {
                 rpsChoices.classList.add('hidden');
                 const winnerId = determineRPSWinner();
                 if (winnerId === -1) { 
                     rpsResultText.innerHTML = `Hòa! Cả hai cùng ra ${rpsMap[me.rpsChoice]}. Chơi lại!`;
                     if (myPlayerIndex === 0) continueBtn.classList.remove('hidden'); 
                     else gameStatus.textContent = 'Hòa! Đang chờ chủ phòng chơi lại...';
                 } else { 
                     const winnerName = gameState.players[winnerId]?.name || `Người chơi ${winnerId + 1}`;
                     const p1Name = gameState.players[0]?.name || 'Người chơi 1';
                     const p2Name = gameState.players[1]?.name || 'Người chơi 2';
                     rpsResultText.innerHTML = `${p1Name} ra ${rpsMap[gameState.players[0].rpsChoice]}, ${p2Name} ra ${rpsMap[gameState.players[1].rpsChoice]}. <br> <span class="text-green-600">${winnerName} thắng và đi trước!</span>`;
                     if (myPlayerIndex === winnerId) continueBtn.classList.remove('hidden'); 
                     else gameStatus.textContent = `Đang chờ ${winnerName} tiếp tục...`;
                 }
             } else if (me?.rpsChoice) {
                 gameStatus.textContent = `Đã chọn. Đang chờ ${opponent?.name || 'đối thủ'}...`;
                 rpsChoices.classList.add('hidden');
             } else {
                 gameStatus.textContent = 'Đến lượt bạn! Hãy ra Kéo, Búa, hoặc Bao.';
             }
        }

        function handleBettingUI(me, opponent) {
            bettingView.classList.remove('hidden');
            renderBettingBoard();
            if (gameState.turn === myPlayerIndex) {
                gameStatus.textContent = 'Đến lượt bạn! Hãy chọn một số để cược.';
            } else {
                gameStatus.textContent = `Đang chờ ${opponent?.name || 'đối thủ'} đặt cược...`;
            }
        }

        function handleRollingUI() {
            gameStatus.textContent = 'Tất cả đã cược! Chuẩn bị xem kết quả!';
            diceRollView.classList.remove('hidden');
            document.getElementById('rolling-text').textContent = "Đang tung xúc xắc...";
            // NEW: Start the 3D dice roll
            startDiceRollAnimation().then(results => {
                if (myPlayerIndex === 0) {
                    rollDice(results.dice1, results.dice2);
                }
            });
        }

        function handleResultUI(me) {
            gameStatus.textContent = 'Vòng chơi kết thúc!';
            resultView.classList.remove('hidden');
            bettingView.classList.remove('hidden'); 
            renderBettingBoard();
            document.getElementById('dice-result-value').textContent = gameState.diceResult;
            
            const winnerText = document.getElementById('winner-text');
            const winnerId = gameState.roundWinner;
            if (winnerId === null) winnerText.textContent = 'Không ai đoán trúng!';
            else if (winnerId === -1) winnerText.textContent = 'Cả hai người chơi đều đoán trúng! Mỗi người 1 điểm.';
            else winnerText.textContent = `${gameState.players[winnerId]?.name || 'Người chơi'} đã thắng vòng này và được 1 điểm!`;

            if (me?.wantsRematch) {
                playAgainBtn.textContent = 'Đang chờ đối thủ...';
                playAgainBtn.disabled = true;
            } else {
                playAgainBtn.textContent = 'Chơi Lại';
                playAgainBtn.disabled = false;
            }
        }
        
        async function updatePlayerState(key, value) {
             const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
             const update = {};
             update[`players.${myPlayerIndex}.${key}`] = value;
             await updateDoc(roomRef, update);
        }

        rpsChoices.addEventListener('click', (e) => {
            const choice = e.target.closest('.rps-choice')?.dataset.choice;
            if (choice) updatePlayerState('rpsChoice', choice);
        });

        function determineRPSWinner() {
            const p1c = gameState.players[0]?.rpsChoice;
            const p2c = gameState.players[1]?.rpsChoice;
            if (!p1c || !p2c) return null; 
            if (p1c === p2c) return -1; 
            if ((p1c === 'r' && p2c === 's') || (p1c === 's' && p2c === 'p') || (p1c === 'p' && p2c === 'r')) return 0;
            return 1;
        }
        
        continueBtn.addEventListener('click', async () => {
             const winner = determineRPSWinner();
             const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
             if (winner === -1) { 
                 if (myPlayerIndex === 0) {
                     await updateDoc(roomRef, { 'players.0.rpsChoice': null, 'players.1.rpsChoice': null });
                 }
             } else { 
                 if (myPlayerIndex === winner) {
                     await updateDoc(roomRef, { status: 'betting', turn: winner, rpsWinner: winner });
                 }
             }
        });
        
        async function placeBet(number) {
            const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
            const opponentIndex = 1 - myPlayerIndex;
            const updates = {};
            updates[`players.${myPlayerIndex}.bet`] = number;
            updates.turn = opponentIndex;
            
            if (gameState.players[opponentIndex] && gameState.players[opponentIndex].bet !== null) {
                updates.status = 'rolling';
                updates.turn = null; 
            }
            await updateDoc(roomRef, updates);
        }

        async function rollDice(die1, die2) {
            if (myPlayerIndex !== 0) return; 
            const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
            
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw "Phòng không tồn tại!";
                    
                    const currentRoomData = roomDoc.data();
                    if (!currentRoomData.players[0] || !currentRoomData.players[1]) {
                        return; 
                    }

                    const total = die1 + die2;

                    const p1 = currentRoomData.players[0];
                    const p2 = currentRoomData.players[1];
                    
                    const p1Score = Number.isFinite(p1.score) ? p1.score : 0;
                    const p2Score = Number.isFinite(p2.score) ? p2.score : 0;

                    let p1Won = p1.bet === total;
                    let p2Won = p2.bet === total;

                    transaction.update(roomRef, {
                        diceFaces: [die1, die2],
                        diceResult: total,
                        status: 'results',
                        'players.0.score': p1Score + (p1Won ? 1 : 0),
                        'players.1.score': p2Score + (p2Won ? 1 : 0),
                        roundWinner: p1Won && p2Won ? -1 : (p1Won ? 0 : (p2Won ? 1 : null))
                    });
                });
            } catch (e) {
                console.error("Giao dịch tung xúc xắc thất bại: ", e);
            }
        }
        
        playAgainBtn.addEventListener('click', () => {
             updatePlayerState('wantsRematch', true);
        });
        
        async function checkAndResetForRematch() {
            if (
                gameState.status === 'results' &&
                gameState.players[0]?.wantsRematch &&
                gameState.players[1]?.wantsRematch &&
                myPlayerIndex === 0
            ) {
                const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
                try {
                    await runTransaction(db, async (transaction) => {
                        const roomDoc = await transaction.get(roomRef);
                        if (!roomDoc.exists()) return;

                        const roomData = roomDoc.data();
                        
                        if (roomData.status !== 'results' || !roomData.players[0]?.wantsRematch || !roomData.players[1]?.wantsRematch) {
                            return;
                        }
                        
                        const nextTurn = roomData.roundWinner !== null && roomData.roundWinner !== -1 ? roomData.roundWinner : roomData.rpsWinner;

                        transaction.update(roomRef, {
                            status: 'betting',
                            turn: nextTurn,
                            rpsWinner: nextTurn,
                            diceResult: null,
                            roundWinner: null,
                            diceFaces: null,
                            'players.0.bet': null,
                            'players.0.wantsRematch': false,
                            'players.0.rpsChoice': null,
                            'players.1.bet': null,
                            'players.1.wantsRematch': false,
                            'players.1.rpsChoice': null,
                        });
                    });
                } catch (e) {
                    console.error("Giao dịch chơi lại thất bại: ", e);
                }
            }
        }

        function renderBettingBoard() {
             const board = document.getElementById('betting-board');
             board.innerHTML = '';
             const me = gameState.players[myPlayerIndex];
             const opponent = gameState.players[1 - myPlayerIndex];
             const myTurn = gameState.status === 'betting' && gameState.turn === myPlayerIndex;

             for (let i = 2; i <= 12; i++) {
                 const circle = document.createElement('button');
                 circle.textContent = i;
                 let opponentBet = opponent?.bet;
                 let classes = 'bet-circle w-16 h-16 rounded-full flex items-center justify-center text-2xl font-bold border-4 transition ';
                 if (i === me?.bet) classes += 'selected-by-me ';
                 else if (i === opponentBet) classes += 'selected-by-opponent ';
                 else classes += 'bg-white border-gray-300 ';
                 
                 if (myTurn && !me?.bet && i !== opponentBet) {
                     classes += 'hover:bg-blue-200 cursor-pointer';
                     circle.disabled = false;
                 } else {
                     classes += 'opacity-70 cursor-not-allowed';
                     circle.disabled = true;
                 }
                 if (gameState.status === 'results' && i === gameState.diceResult) classes += ' correct-guess border-green-400';
                 circle.className = classes;
                 if(!circle.disabled) circle.onclick = () => placeBet(i);
                 board.appendChild(circle);
             }
        }
        
        // --- 3D Dice Roll Logic ---
        let scene, camera, renderer, world, dice = [], diceMeshes = [];

        function init3D() {
            const canvas = document.getElementById('dice-roll-canvas');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.set(0, 5, 5);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.shadowMap.enabled = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            world = new CANNON.World();
            world.gravity.set(0, -9.82 * 2, 0); // Stronger gravity

            const groundMaterial = new CANNON.Material('groundMaterial');
            const groundBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Plane(),
                material: groundMaterial
            });
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);

            const groundMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                new THREE.MeshStandardMaterial({ color: 0xf0f0f0 })
            );
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            const diceMaterial = new CANNON.Material('diceMaterial');
            const contactMaterial = new CANNON.ContactMaterial(groundMaterial, diceMaterial, {
                friction: 0.1,
                restitution: 0.5
            });
            world.addContactMaterial(contactMaterial);

            const diceGeometry = new THREE.BoxGeometry(1, 1, 1);
            const dotMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
            const faceMaterials = [
                new THREE.MeshStandardMaterial({ map: createDiceTexture(1) }), // right
                new THREE.MeshStandardMaterial({ map: createDiceTexture(6) }), // left
                new THREE.MeshStandardMaterial({ map: createDiceTexture(2) }), // top
                new THREE.MeshStandardMaterial({ map: createDiceTexture(5) }), // bottom
                new THREE.MeshStandardMaterial({ map: createDiceTexture(3) }), // front
                new THREE.MeshStandardMaterial({ map: createDiceTexture(4) }), // back
            ];

            for(let i=0; i<2; i++) {
                const mesh = new THREE.Mesh(diceGeometry, faceMaterials);
                mesh.castShadow = true;
                scene.add(mesh);
                diceMeshes.push(mesh);

                const body = new CANNON.Body({
                    mass: 1,
                    shape: new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)),
                    material: diceMaterial
                });
                world.addBody(body);
                dice.push(body);
            }
        }

        function createDiceTexture(num) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 128;
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, 128, 128);
            ctx.fillStyle = 'black';
            
            const dotRadius = 12;
            const positions = {
                1: [[64, 64]],
                2: [[32, 32], [96, 96]],
                3: [[32, 32], [64, 64], [96, 96]],
                4: [[32, 32], [96, 32], [32, 96], [96, 96]],
                5: [[32, 32], [96, 32], [64, 64], [32, 96], [96, 96]],
                6: [[32, 32], [32, 64], [32, 96], [96, 32], [96, 64], [96, 96]]
            };
            
            positions[num].forEach(([x, y]) => {
                ctx.beginPath();
                ctx.arc(x, y, dotRadius, 0, Math.PI * 2);
                ctx.fill();
            });
            
            return new THREE.CanvasTexture(canvas);
        }

        let animationFrameId;
        function startDiceRollAnimation() {
            return new Promise(resolve => {
                dice.forEach((d, i) => {
                    d.position.set(Math.random() * 2 - 1, 3 + i * 1.5, Math.random() * 2 - 1);
                    d.quaternion.setFromAxisAngle(
                        new CANNON.Vec3(Math.random(), Math.random(), Math.random()).unit(),
                        Math.random() * Math.PI * 2
                    );
                    d.velocity.set((Math.random() - 0.5) * 10, Math.random() * 2, (Math.random() - 0.5) * 10);
                    d.angularVelocity.set((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20);
                });

                let lastTime;
                let settledCount = 0;
                const settleThreshold = 0.1;

                function animate(time) {
                    if (lastTime !== undefined) {
                        const dt = (time - lastTime) / 1000;
                        world.step(1 / 60, dt);
                    }
                    lastTime = time;

                    let allSettled = true;
                    for(let i=0; i<dice.length; i++) {
                        diceMeshes[i].position.copy(dice[i].position);
                        diceMeshes[i].quaternion.copy(dice[i].quaternion);
                        if(dice[i].velocity.length() > settleThreshold || dice[i].angularVelocity.length() > settleThreshold) {
                            allSettled = false;
                        }
                    }

                    renderer.render(scene, camera);
                    animationFrameId = requestAnimationFrame(animate);

                    if(allSettled) {
                        settledCount++;
                        if(settledCount > 60) { // Wait for 1 second of settled state
                            cancelAnimationFrame(animationFrameId);
                            const results = {
                                dice1: getDiceFace(dice[0]),
                                dice2: getDiceFace(dice[1])
                            };
                            resolve(results);
                        }
                    } else {
                        settledCount = 0;
                    }
                }
                animate();
            });
        }

        function getDiceFace(diceBody) {
            const up = new THREE.Vector3(0, 1, 0);
            let maxDot = -1;
            let topFaceIndex = -1;

            const faceNormals = [
                new THREE.Vector3(1, 0, 0),  // right (1)
                new THREE.Vector3(-1, 0, 0), // left  (6)
                new THREE.Vector3(0, 1, 0),  // top   (2)
                new THREE.Vector3(0, -1, 0), // bottom(5)
                new THREE.Vector3(0, 0, 1),  // front (3)
                new THREE.Vector3(0, 0, -1)  // back  (4)
            ];
            const faceValues = [1, 6, 2, 5, 3, 4];

            for (let i = 0; i < faceNormals.length; i++) {
                const worldNormal = new THREE.Vector3();
                worldNormal.copy(faceNormals[i]);
                const q = new THREE.Quaternion(diceBody.quaternion.x, diceBody.quaternion.y, diceBody.quaternion.z, diceBody.quaternion.w);
                worldNormal.applyQuaternion(q);
                const dot = worldNormal.dot(up);
                if (dot > maxDot) {
                    maxDot = dot;
                    topFaceIndex = i;
                }
            }
            return faceValues[topFaceIndex];
        }

        // --- Initial Load ---
        enterLobbyBtn.addEventListener('click', () => {
            localPlayerName = playerNameInput.value.trim();
            if (!localPlayerName) {
                showNotification("Vui lòng nhập tên của bạn.", true);
                return;
            }
            localStorage.setItem('dice_player_name', localPlayerName);
            goToLobby();
        });

        (async () => {
            const savedName = localStorage.getItem('dice_player_name');
            if (savedName) {
                playerNameInput.value = savedName;
                localPlayerName = savedName; 
            }

            enterLobbyBtn.disabled = true;
            enterLobbyBtn.textContent = 'Đang kết nối...';
            enterLobbyBtn.classList.add('bg-gray-400', 'cursor-not-allowed');
            enterLobbyBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    enterLobbyBtn.disabled = false;
                    enterLobbyBtn.textContent = 'Vào Sảnh Chờ';
                    enterLobbyBtn.classList.remove('bg-gray-400', 'cursor-not-allowed');
                    enterLobbyBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                } else {
                    try {
                        await signInAnonymously(auth);
                    } catch (error) {
                        showNotification("Không thể kết nối. Vui lòng làm mới trang.", true);
                        enterLobbyBtn.textContent = 'Lỗi kết nối';
                    }
                }
            });

            showView(nameView);
            init3D();
        })();
    </script>
</body>
</html>

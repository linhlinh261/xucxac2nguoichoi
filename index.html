<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trò Chơi Cược Xúc Xắc 3D (Online với Phòng)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Three.js for 3D Dice -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // This configuration will be populated by the environment
        if (typeof __firebase_config === 'undefined') {
            window.__firebase_config = JSON.stringify({
                apiKey: "AIzaSyCUrFw_GAv5bIGfwFfuiwCuBcjaNqFohVs",
                authDomain: "tonghaixucxac.firebaseapp.com",
                projectId: "tonghaixucxac",
                storageBucket: "tonghaixucxac.firebasestorage.app",
                messagingSenderId: "282682257745",
                appId: "1:282682257745:web:b1d53ac3f903d95be8a370",
            });
        }
    </script>
    <style>
        body { font-family: 'Roboto', sans-serif; }
        .room-btn { transition: all 0.2s ease-in-out; }
        .room-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .bet-circle.selected-by-me { background-color: #3b82f6; color: white; border-color: #1d4ed8; }
        .bet-circle.selected-by-opponent { background-color: #ef4444; color: white; border-color: #b91c1c; }
        .bet-circle.correct-guess { animation: pulse-green 2s infinite; }
        @keyframes pulse-green { 0%, 100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.7); } 50% { box-shadow: 0 0 0 10px rgba(74, 222, 128, 0); } }
        #notification-toast { transition: opacity 0.3s, top 0.3s; z-index: 9999; }
        .danger { background-color: #ef4444 !important; color: #fff !important; }
        /* Canvas for 3D dice should not be interactive by default */
        #dice1-3d canvas, #dice2-3d canvas {
            display: block;
            margin: auto;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen p-4">
<div id="app-container" class="w-full max-w-5xl mx-auto">
    <!-- Notification Toast -->
    <div id="notification-toast" class="fixed top-5 right-5 bg-blue-600 text-white py-2 px-4 rounded-lg shadow-lg transition-opacity duration-300 z-50 opacity-0 pointer-events-none"></div>
    
    <!-- Name Entry View -->
    <div id="name-view">
        <div class="bg-white p-8 rounded-xl shadow-lg text-center">
            <h1 class="text-3xl font-bold mb-6 text-gray-700">Chào mừng đến với Cược Xúc Xắc 3D</h1>
            <div class="mb-6">
                <label for="player-name" class="block text-lg font-medium mb-2">Nhập tên của bạn để bắt đầu</label>
                <input type="text" id="player-name" class="w-full max-w-sm mx-auto p-3 border-2 border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
            </div>
            <button id="enter-lobby-btn" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700 transition-all duration-300 shadow-md">Vào Sảnh Chờ</button>
        </div>
    </div>

    <!-- Lobby View -->
    <div id="lobby-view" class="hidden">
        <div class="bg-white p-8 rounded-xl shadow-lg">
            <div class="flex justify-between items-center mb-6">
                <h1 class="text-3xl font-bold text-gray-700">Sảnh Chờ</h1>
                <p>Xin chào, <strong id="lobby-player-name"></strong>!</p>
            </div>
            <div id="room-list" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-4"></div>
        </div>
    </div>

    <!-- Game View -->
    <div id="game-view" class="hidden">
        <div class="bg-white p-6 rounded-xl shadow-lg w-full">
            <div class="flex justify-between items-center border-b pb-4 mb-4">
                <h2 class="text-2xl font-bold text-gray-800">Phòng <span id="game-room-id"></span></h2>
                <button id="quit-game-btn" class="bg-red-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 transition">Rời Phòng</button>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4 text-center">
                <div id="player-1-info" class="p-4 bg-blue-100 rounded-lg border-2 border-blue-300"></div>
                <div id="player-2-info" class="p-4 bg-red-100 rounded-lg border-2 border-red-300"></div>
            </div>
            <div id="game-status" class="text-center text-xl font-semibold my-4 p-3 bg-yellow-100 text-yellow-800 rounded-lg"></div>
            <div id="main-game-area" class="mt-6">
                <!-- Rock Paper Scissors View -->
                <div id="rps-view" class="hidden text-center">
                    <h3 class="text-lg font-medium mb-4">Oẳn tù xì để quyết định ai đi trước!</h3>
                    <div id="rps-choices" class="flex justify-center gap-4">
                        <button data-choice="r" class="rps-choice text-5xl p-4 rounded-lg hover:bg-gray-200 transition">✊</button>
                        <button data-choice="p" class="rps-choice text-5xl p-4 rounded-lg hover:bg-gray-200 transition">✋</button>
                        <button data-choice="s" class="rps-choice text-5xl p-4 rounded-lg hover:bg-gray-200 transition">✂️</button>
                    </div>
                    <div id="rps-result-text" class="mt-4 text-2xl font-bold"></div>
                    <button id="continue-btn" class="hidden mt-4 bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700">Tiếp Tục</button>
                </div>
                <!-- Betting View -->
                <div id="betting-view" class="hidden">
                    <div id="betting-board" class="flex flex-wrap justify-center gap-3"></div>
                </div>
                <!-- 3D Dice Roll View -->
                <div id="dice-roll-view" class="hidden flex flex-col items-center justify-center min-h-[200px]">
                    <p class="text-2xl font-bold mb-4" id="rolling-text"></p>
                    <div class="flex gap-6 justify-center w-full">
                        <div id="dice1-3d" style="width: 120px; height: 120px;"></div>
                        <div id="dice2-3d" style="width: 120px; height: 120px;"></div>
                    </div>
                </div>
                <!-- Result View -->
                <div id="result-view" class="hidden text-center">
                    <h3 class="text-2xl font-bold mb-2">Kết quả là: <span id="dice-result-value" class="text-blue-600"></span></h3>
                    <p id="winner-text" class="text-xl font-semibold text-green-600 mb-4"></p>
                    <button id="play-again-btn" class="bg-green-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-green-600 transition">Chơi Lại</button>
                </div>
            </div>
        </div>
    </div>
</div>
<script type="module">
// Import Firebase services
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, collection, onSnapshot, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

// --- Use environment-provided variables for Firebase config and App ID ---
const firebaseConfig = JSON.parse(window.__firebase_config || '{}');
const appId = typeof __app_id !== 'undefined' ? __app_id : 'dice-game-standalone';

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

// DOM Elements
const nameView = document.getElementById('name-view');
const lobbyView = document.getElementById('lobby-view');
const gameView = document.getElementById('game-view');
const playerNameInput = document.getElementById('player-name');
const enterLobbyBtn = document.getElementById('enter-lobby-btn');
const roomList = document.getElementById('room-list');
const lobbyPlayerName = document.getElementById('lobby-player-name');
const gameRoomId = document.getElementById('game-room-id');
const quitGameBtn = document.getElementById('quit-game-btn');
const player1Info = document.getElementById('player-1-info');
const player2Info = document.getElementById('player-2-info');
const gameStatus = document.getElementById('game-status');
const rpsView = document.getElementById('rps-view');
const bettingView = document.getElementById('betting-view');
const diceRollView = document.getElementById('dice-roll-view');
const resultView = document.getElementById('result-view');
const playAgainBtn = document.getElementById('play-again-btn');
const rpsChoices = document.getElementById('rps-choices');
const rpsResultText = document.getElementById('rps-result-text');
const continueBtn = document.getElementById('continue-btn');
const notificationToast = document.getElementById('notification-toast');

// Global state variables
let localPlayerName = '';
let currentRoomId = null;
let myPlayerIndex = null;
let gameState = {};
let lobbyUnsubscribe = null;
let gameUnsubscribe = null;
let userId;
let joinTimeout = null;
let diceAnimationIds = {}; // To manage and cancel animation loops

// Firestore collection path using the dynamic App ID
const roomsCollectionPath = `/artifacts/${appId}/public/data/dice-game-rooms`;

// --- UTILITY FUNCTIONS ---

function showNotification(message, danger = false) {
    notificationToast.textContent = message;
    notificationToast.classList.remove('opacity-0');
    if (danger) notificationToast.classList.add('danger');
    else notificationToast.classList.remove('danger');
    setTimeout(() => notificationToast.classList.add('opacity-0'), 4000);
}

function showView(view) {
    [nameView, lobbyView, gameView].forEach(v => v.classList.add('hidden'));
    view.classList.remove('hidden');
}

// --- 3D DICE LOGIC (using Three.js) ---

function createDiceTexture(n) {
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, 128, 128);
    ctx.fillStyle = '#000';
    const dot = (x, y) => { ctx.beginPath(); ctx.arc(x, y, 12, 0, 2 * Math.PI); ctx.fill(); };
    if (n === 1) { dot(64, 64); }
    if (n === 2) { dot(32, 32); dot(96, 96); }
    if (n === 3) { dot(32, 32); dot(64, 64); dot(96, 96); }
    if (n === 4) { dot(32, 32); dot(96, 32); dot(32, 96); dot(96, 96); }
    if (n === 5) { dot(32, 32); dot(96, 32); dot(64, 64); dot(32, 96); dot(96, 96); }
    if (n === 6) { dot(32, 32); dot(96, 32); dot(32, 64); dot(96, 64); dot(32, 96); dot(96, 96); }
    return new THREE.CanvasTexture(canvas);
}

function setFinalRotation(group, value) { // Takes a group now
    const rotations = {
        1: { x: 0, y: 0, z: 0 },
        2: { x: -Math.PI / 2, y: 0, z: 0 },
        3: { x: 0, y: Math.PI / 2, z: 0 },
        4: { x: 0, y: -Math.PI / 2, z: 0 },
        5: { x: Math.PI / 2, y: 0, z: 0 },
        6: { x: Math.PI, y: 0, z: 0 },
    };
    const r = rotations[value] || rotations[1];
    group.rotation.set(r.x, r.y, r.z);
}

// UPDATED: createDice3D function to include edges
function createDice3D(containerId, value, animate = false) {
    // Cancel any existing animation for this container
    if (diceAnimationIds[containerId]) {
        cancelAnimationFrame(diceAnimationIds[containerId]);
    }

    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = ''; // Clear previous renderer
    
    const width = container.clientWidth;
    const height = container.clientHeight;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
    camera.position.z = 150;

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(width, height);
    container.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 100, 150);
    scene.add(directionalLight);

    // Create a group to hold the dice body and its outline
    const diceGroup = new THREE.Group();
    scene.add(diceGroup);

    const diceMaterials = [
        new THREE.MeshStandardMaterial({ map: createDiceTexture(4) }), // right
        new THREE.MeshStandardMaterial({ map: createDiceTexture(3) }), // left
        new THREE.MeshStandardMaterial({ map: createDiceTexture(2) }), // top
        new THREE.MeshStandardMaterial({ map: createDiceTexture(5) }), // bottom
        new THREE.MeshStandardMaterial({ map: createDiceTexture(1) }), // front
        new THREE.MeshStandardMaterial({ map: createDiceTexture(6) }), // back
    ];

    const geometry = new THREE.BoxGeometry(70, 70, 70);
    const mesh = new THREE.Mesh(geometry, diceMaterials);
    diceGroup.add(mesh); // Add dice body to the group

    // --- ADDED: Create and add black edges ---
    const edges = new THREE.EdgesGeometry(geometry);
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
    const lineSegments = new THREE.LineSegments(edges, lineMaterial);
    diceGroup.add(lineSegments); // Add edges to the group
    // --- END ADDED ---

    // Set initial state if not animating
    if (!animate) {
        setFinalRotation(diceGroup, value);
    }

    // A single, continuous loop for both spinning and static states
    function loop() {
        if (animate) {
            // Rotate the entire group
            diceGroup.rotation.x += 0.15 + Math.random() * 0.1;
            diceGroup.rotation.y += 0.16 + Math.random() * 0.1;
        }
        renderer.render(scene, camera);
        diceAnimationIds[containerId] = requestAnimationFrame(loop);
    }
    
    loop(); // Start the loop
}

function stopAllDiceAnimations() {
    for (const id in diceAnimationIds) {
        if (diceAnimationIds[id]) {
            cancelAnimationFrame(diceAnimationIds[id]);
            diceAnimationIds[id] = null;
        }
    }
    const d1 = document.getElementById('dice1-3d');
    const d2 = document.getElementById('dice2-3d');
    if (d1) d1.innerHTML = '';
    if (d2) d2.innerHTML = '';
}

// --- NAVIGATION & ROOM MANAGEMENT ---

async function goToLobby() {
    stopAllDiceAnimations(); // Clean up 3D scenes
    if (joinTimeout) clearTimeout(joinTimeout);
    if (gameUnsubscribe) gameUnsubscribe();
    gameUnsubscribe = null;
    currentRoomId = null;
    myPlayerIndex = null;
    lobbyPlayerName.textContent = localPlayerName;
    showView(lobbyView);
    renderLobby({});
    listenToLobby();
}

async function leaveRoom() {
    stopAllDiceAnimations(); // Clean up 3D scenes
    if (!currentRoomId || !userId) return goToLobby();
    const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
    try {
        await runTransaction(db, async (transaction) => {
            const roomDoc = await transaction.get(roomRef);
            if (!roomDoc.exists()) return;
            
            let playersData = roomDoc.data().players;
            let players = Array.isArray(playersData) ? playersData : [playersData['0'] || null, playersData['1'] || null];
            
            const idx = players.findIndex(p => p && p.id === userId);
            if (idx !== -1) players[idx] = null;
            
            const stillPlayers = players.filter(p => p && p.id);
            if (stillPlayers.length === 0) {
                transaction.delete(roomRef);
            } else {
                let fixedPlayers = [null, null];
                if (stillPlayers.length === 1) fixedPlayers = [stillPlayers[0], null];
                transaction.set(roomRef, {
                    ...roomDoc.data(),
                    players: fixedPlayers,
                    playerCount: stillPlayers.length,
                    status: 'waiting'
                });
            }
        });
    } catch (error) {
        console.error("Error leaving room:", error);
        showNotification("Lỗi khi rời phòng.");
    } finally {
        goToLobby();
    }
}
quitGameBtn.addEventListener('click', leaveRoom);

// --- LOBBY LOGIC ---

function listenToLobby() {
    if (lobbyUnsubscribe) lobbyUnsubscribe();
    const roomsRef = collection(db, roomsCollectionPath);
    lobbyUnsubscribe = onSnapshot(roomsRef, (snapshot) => {
        const roomsData = {};
        snapshot.forEach(doc => {
            const room = doc.data();
            if(room.id) roomsData[room.id] = room;
        });
        renderLobby(roomsData);
    });
}

function renderLobby(roomsData) {
    roomList.innerHTML = '';
    for (let i = 1; i <= 30; i++) {
        const room = roomsData[i];
        const btn = document.createElement('button');
        btn.className = 'room-btn p-4 border rounded-lg shadow-sm';
        let text = '';
        let statusClass = '';
        if (room && room.playerCount > 0) {
            text = `${room.playerCount} / 2`;
            if (room.playerCount === 1) {
                statusClass = 'bg-yellow-100 border-yellow-300';
                btn.disabled = false;
            } else {
                statusClass = 'bg-red-200 border-red-400 text-gray-500';
                btn.disabled = true;
            }
        } else {
            text = 'Trống';
            statusClass = 'bg-green-100 border-green-300 hover:bg-green-200';
            btn.disabled = false;
        }
        btn.innerHTML = `<div class="font-bold text-lg">Phòng ${i}</div><div class="text-sm">${text}</div>`;
        btn.classList.add(...statusClass.split(' '));
        btn.dataset.roomId = i;
        btn.onclick = () => joinRoom(i);
        roomList.appendChild(btn);
    }
}

async function joinRoom(roomId) {
    if (!userId) {
        showNotification("Đang xác thực, vui lòng đợi một lát...");
        return;
    }
    const roomRef = doc(db, roomsCollectionPath, `room-${roomId}`);
    try {
        showView(gameView);
        gameRoomId.textContent = roomId;
        gameStatus.textContent = 'Đang tham gia phòng...';
        
        joinTimeout = setTimeout(() => {
            if (myPlayerIndex === null) {
                showNotification("Không thể vào phòng. Vui lòng thử lại!", true);
                goToLobby();
            }
        }, 10000);

        let joinOK = false;
        await runTransaction(db, async (transaction) => {
            const roomDoc = await transaction.get(roomRef);
            let roomData;
            if (!roomDoc.exists()) {
                roomData = {
                    id: roomId,
                    players: [{ id: userId, name: localPlayerName, score: 0, rpsChoice: null, bet: null, wantsRematch: false }, null],
                    playerCount: 1,
                    status: 'waiting',
                };
                transaction.set(roomRef, roomData);
                joinOK = true;
                myPlayerIndex = 0;
                return;
            }
            
            roomData = roomDoc.data();
            let players = Array.isArray(roomData.players) ? roomData.players : [roomData.players['0'] || null, roomData.players['1'] || null];

            let slot = -1;
            for (let i = 0; i < 2; ++i) {
                if (!players[i] || !players[i].id) {
                    slot = i; break;
                }
            }
            if (slot === -1) throw new Error("Phòng đã đầy!");
            
            players[slot] = { id: userId, name: localPlayerName, score: 0, rpsChoice: null, bet: null, wantsRematch: false };
            roomData.playerCount = players.filter(p => p && p.id).length;
            if(roomData.playerCount === 2) roomData.status = 'rps';
            
            transaction.set(roomRef, {
                ...roomData,
                players: [players[0] || null, players[1] || null]
            });
            joinOK = true;
            myPlayerIndex = slot;
        });

        if (!joinOK) throw new Error("Không thể vào phòng, thử lại.");
        if(lobbyUnsubscribe) lobbyUnsubscribe();
        currentRoomId = roomId;
        listenToGame(roomId);
    } catch (e) {
        showNotification(e.message || "Lỗi không xác định", true);
        goToLobby();
    }
}

// --- GAME STATE LISTENER & UI UPDATES ---

function listenToGame(roomId) {
    if (gameUnsubscribe) gameUnsubscribe();
    const roomRef = doc(db, roomsCollectionPath, `room-${roomId}`);
    gameUnsubscribe = onSnapshot(roomRef, (docSnap) => {
        if (!docSnap.exists()) {
            showNotification("Chủ phòng đã rời đi. Quay về sảnh chờ.");
            goToLobby();
            return;
        }
        gameState = docSnap.data();
        
        if (gameState.players && !Array.isArray(gameState.players)) {
            const playersMap = gameState.players;
            gameState.players = [playersMap['0'] || null, playersMap['1'] || null];
        }

        if (myPlayerIndex === null || myPlayerIndex === -1) {
            myPlayerIndex = gameState.players.findIndex(p => p && p.id === userId);
        }
        updateGameUI();
    });
}

function updateGameUI() {
    if (!gameState || !gameState.players) {
        gameStatus.textContent = 'Đang tải dữ liệu phòng...';
        return;
    }

    if (myPlayerIndex === -1 || myPlayerIndex === null) {
        gameStatus.textContent = 'Đang đồng bộ...';
        return;
    }
    if (joinTimeout) clearTimeout(joinTimeout);

    const opponentIndex = 1 - myPlayerIndex;
    const me = gameState.players[myPlayerIndex];
    const opponent = gameState.players[opponentIndex];
    
    gameRoomId.textContent = currentRoomId;

    function renderPlayerBox(el, player, isMe) {
        if (!player) {
            el.innerHTML = `<h3 class="font-bold text-lg">Đang chờ...</h3>`;
            return;
        }
        const rpsMap = { r: '✊', p: '✋', s: '✂️' };
        let rpsDisplay = '';
        if (player.rpsChoice && gameState.status === 'rps') {
            if (gameState.players[0]?.rpsChoice && gameState.players[1]?.rpsChoice) {
                rpsDisplay = `<p class="mt-1">Ra: <span class="text-2xl">${rpsMap[player.rpsChoice]}</span></p>`;
            } else {
                rpsDisplay = `<p class="mt-1">Ra: <span class="text-xl font-bold text-gray-500">Đã chọn</span></p>`;
            }
        }
        const displayName = player.name ? (isMe ? player.name + " (Bạn)" : player.name) : (isMe ? "Bạn" : "Đối thủ");
        el.innerHTML = `
            <h3 class="text-lg font-bold">${displayName}</h3>
            <p class="text-2xl font-black text-indigo-600">${Number.isFinite(player.score) ? player.score : 0} Điểm</p>
            ${player.bet ? `<p class="mt-1">Đã cược: <span class="font-bold text-xl">${player.bet}</span></p>` : ''}
            ${rpsDisplay}
        `;
    }

    renderPlayerBox(player1Info, gameState.players[0], myPlayerIndex === 0);
    renderPlayerBox(player2Info, gameState.players[1], myPlayerIndex === 1);

    [rpsView, bettingView, diceRollView, resultView].forEach(v => v.classList.add('hidden'));
    
    switch(gameState.status) {
        case 'waiting':
            gameStatus.textContent = 'Đang chờ người chơi thứ hai...';
            break;
        case 'rps': handleRPSUI(me, opponent); break;
        case 'betting': handleBettingUI(me, opponent); break;
        case 'rolling': handleRollingUI(); break;
        case 'results': handleResultUI(me); break;
    }

    if (gameState.status === 'results' && me?.wantsRematch && opponent?.wantsRematch) {
        checkAndResetForRematch();
    }
}

// --- GAME LOGIC & STATE UPDATES ---

async function updatePlayerState(key, value) {
    if (typeof myPlayerIndex !== 'number' || myPlayerIndex < 0 || myPlayerIndex > 1) {
        showNotification('Lỗi xác định người chơi. Hãy thử vào lại phòng.', true);
        return;
    }
    const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
    try {
        await runTransaction(db, async (transaction) => {
            const roomDoc = await transaction.get(roomRef);
            if (!roomDoc.exists()) return;
            const data = roomDoc.data();
            const players = Array.isArray(data.players) ? [...data.players] : [data.players['0'] || null, data.players['1'] || null];
            
            if (!players[myPlayerIndex]) players[myPlayerIndex] = {}; 
            
            players[myPlayerIndex] = {...players[myPlayerIndex], [key]: value};
            transaction.update(roomRef, { players });
        });
    } catch (error) {
        console.error("Error updating player state:", error);
        showNotification("Có lỗi khi cập nhật trạng thái.", true);
    }
}

// --- RPS Stage ---
function handleRPSUI(me, opponent) {
    rpsView.classList.remove('hidden');
    rpsResultText.textContent = '';
    continueBtn.classList.add('hidden');
    rpsChoices.classList.remove('hidden');
    const rpsMap = { r: 'Búa ✊', p: 'Bao ✋', s: 'Kéo ✂️' };

    if (me?.rpsChoice && opponent?.rpsChoice) {
        rpsChoices.classList.add('hidden');
        const winnerId = determineRPSWinner();
        if (winnerId === -1) {
            rpsResultText.innerHTML = `Hòa! Cả hai cùng ra ${rpsMap[me.rpsChoice]}. Chơi lại!`;
            if (myPlayerIndex === 0) continueBtn.classList.remove('hidden');
            else gameStatus.textContent = 'Hòa! Đang chờ chủ phòng chơi lại...';
        } else {
            const winnerName = gameState.players[winnerId]?.name || `Người chơi ${winnerId + 1}`;
            const p1Name = gameState.players[0]?.name || 'Người chơi 1';
            const p2Name = gameState.players[1]?.name || 'Người chơi 2';
            rpsResultText.innerHTML = `${p1Name} ra ${rpsMap[gameState.players[0].rpsChoice]}, ${p2Name} ra ${rpsMap[gameState.players[1].rpsChoice]}. <br> <span class="text-green-600">${winnerName} thắng và đi trước!</span>`;
            if (myPlayerIndex === winnerId) continueBtn.classList.remove('hidden');
            else gameStatus.textContent = `Đang chờ ${winnerName} tiếp tục...`;
        }
    } else if (me?.rpsChoice) {
        gameStatus.textContent = `Đã chọn. Đang chờ ${opponent?.name || 'đối thủ'}...`;
        rpsChoices.classList.add('hidden');
    } else {
        gameStatus.textContent = 'Đến lượt bạn! Hãy ra Kéo, Búa, hoặc Bao.';
    }
}

rpsChoices.addEventListener('click', (e) => {
    const choice = e.target.closest('.rps-choice')?.dataset.choice;
    if (choice) updatePlayerState('rpsChoice', choice);
});

continueBtn.addEventListener('click', async () => {
    const winner = determineRPSWinner();
    const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
    await runTransaction(db, async (transaction) => {
        const roomDoc = await transaction.get(roomRef);
        if (!roomDoc.exists()) return;
        const data = roomDoc.data();
        const players = Array.isArray(data.players) ? [...data.players] : [data.players['0'] || null, data.players['1'] || null];
        
        if (winner === -1) {
            if (myPlayerIndex === 0) {
                players[0] = {...players[0], rpsChoice: null};
                players[1] = {...players[1], rpsChoice: null};
                transaction.update(roomRef, { players });
            }
        } else {
            if (myPlayerIndex === winner) {
                transaction.update(roomRef, { status: 'betting', turn: winner, rpsWinner: winner });
            }
        }
    });
});

function determineRPSWinner() {
    const p1c = gameState.players[0]?.rpsChoice;
    const p2c = gameState.players[1]?.rpsChoice;
    if (!p1c || !p2c) return null;
    if (p1c === p2c) return -1;
    if ((p1c === 'r' && p2c === 's') || (p1c === 's' && p2c === 'p') || (p1c === 'p' && p2c === 'r')) return 0;
    return 1;
}

// --- Betting Stage ---
async function placeBet(number) {
    const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
    await runTransaction(db, async (transaction) => {
        const roomDoc = await transaction.get(roomRef);
        if (!roomDoc.exists()) return;
        const data = roomDoc.data();
        const players = Array.isArray(data.players) ? [...data.players] : [data.players['0'] || null, data.players['1'] || null];
        
        players[myPlayerIndex] = {...players[myPlayerIndex], bet: number};
        
        let updateData = { players };
        const opponentIndex = 1 - myPlayerIndex;
        
        if (players[opponentIndex]?.bet !== null && players[opponentIndex]?.bet !== undefined) {
            updateData.status = 'rolling';
            updateData.turn = null;
        } else {
            updateData.turn = opponentIndex;
        }
        transaction.update(roomRef, updateData);
    });
}

function handleBettingUI(me, opponent) {
    bettingView.classList.remove('hidden');
    renderBettingBoard();
    if (gameState.turn === myPlayerIndex) {
        gameStatus.textContent = 'Đến lượt bạn! Hãy chọn một số để cược.';
    } else {
        gameStatus.textContent = `Đang chờ ${opponent?.name || 'đối thủ'} đặt cược...`;
    }
}

function renderBettingBoard() {
    const board = document.getElementById('betting-board');
    board.innerHTML = '';
    const me = gameState.players[myPlayerIndex];
    const opponent = gameState.players[1 - myPlayerIndex];
    const myTurn = gameState.status === 'betting' && gameState.turn === myPlayerIndex;

    for (let i = 2; i <= 12; i++) {
        const circle = document.createElement('button');
        circle.textContent = i;
        const opponentBet = opponent?.bet;
        let classes = 'bet-circle w-16 h-16 rounded-full flex items-center justify-center text-2xl font-bold border-4 transition ';
        
        if (i === me?.bet) classes += 'selected-by-me ';
        else if (i === opponentBet) classes += 'selected-by-opponent ';
        else classes += 'bg-white border-gray-300 ';

        if (myTurn && !me?.bet && i !== opponentBet) {
            classes += 'hover:bg-blue-200 cursor-pointer';
            circle.disabled = false;
        } else {
            classes += 'opacity-70 cursor-not-allowed';
            circle.disabled = true;
        }

        if (gameState.status === 'results' && i === gameState.diceResult) {
            classes += ' correct-guess border-green-400';
        }

        circle.className = classes;
        if(!circle.disabled) circle.onclick = () => placeBet(i);
        board.appendChild(circle);
    }
}

// --- Rolling & Results Stage ---
function handleRollingUI() {
    gameStatus.textContent = 'Tất cả đã cược! Chuẩn bị xem kết quả!';
    diceRollView.classList.remove('hidden');
    document.getElementById('rolling-text').textContent = "Đang tung xúc xắc...";
    
    // Start 3D animation
    createDice3D('dice1-3d', 1, true);
    createDice3D('dice2-3d', 1, true);

    if (myPlayerIndex === 0) setTimeout(rollDice, 2500);
}

async function rollDice() {
    if (myPlayerIndex !== 0) return;
    const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
    await runTransaction(db, async (transaction) => {
        const roomDoc = await transaction.get(roomRef);
        if (!roomDoc.exists()) return;
        const data = roomDoc.data();
        const players = Array.isArray(data.players) ? [...data.players] : [data.players['0'] || null, data.players['1'] || null];
        
        const die1 = Math.floor(Math.random() * 6) + 1;
        const die2 = Math.floor(Math.random() * 6) + 1;
        const total = die1 + die2;

        let p1Won = players[0]?.bet === total;
        let p2Won = players[1]?.bet === total;

        players[0] = {...players[0], score: (players[0]?.score||0) + (p1Won ? 1 : 0)};
        players[1] = {...players[1], score: (players[1]?.score||0) + (p2Won ? 1 : 0)};
        
        transaction.update(roomRef, {
            players,
            diceFaces: [die1, die2],
            diceResult: total,
            status: 'results',
            roundWinner: p1Won && p2Won ? -1 : (p1Won ? 0 : (p2Won ? 1 : null))
        });
    });
}

function handleResultUI(me) {
    gameStatus.textContent = 'Vòng chơi kết thúc!';
    resultView.classList.remove('hidden');
    bettingView.classList.remove('hidden'); 
    renderBettingBoard();
    
    document.getElementById('dice-result-value').textContent = gameState.diceResult;
    
    if (gameState.diceFaces) {
        diceRollView.classList.remove('hidden');
        document.getElementById('rolling-text').textContent = "Kết quả xúc xắc:";
        // Show final 3D dice result
        createDice3D('dice1-3d', gameState.diceFaces[0], false);
        createDice3D('dice2-3d', gameState.diceFaces[1], false);
    }

    const winnerText = document.getElementById('winner-text');
    const winnerId = gameState.roundWinner;
    if (winnerId === null) winnerText.textContent = 'Không ai đoán trúng!';
    else if (winnerId === -1) winnerText.textContent = 'Cả hai người chơi đều đoán trúng! Mỗi người 1 điểm.';
    else winnerText.textContent = `${gameState.players[winnerId]?.name || 'Người chơi'} đã thắng vòng này và được 1 điểm!`;

    if (me?.wantsRematch) {
        playAgainBtn.textContent = 'Đang chờ đối thủ...';
        playAgainBtn.disabled = true;
    } else {
        playAgainBtn.textContent = 'Chơi Lại';
        playAgainBtn.disabled = false;
    }
}

// --- Rematch Logic ---
playAgainBtn.addEventListener('click', async () => {
    await updatePlayerState('wantsRematch', true);
});

async function checkAndResetForRematch() {
    if (
        gameState.status === 'results' &&
        gameState.players[0]?.wantsRematch &&
        gameState.players[1]?.wantsRematch &&
        myPlayerIndex === 0
    ) {
        const roomRef = doc(db, roomsCollectionPath, `room-${currentRoomId}`);
        await runTransaction(db, async (transaction) => {
            const roomDoc = await transaction.get(roomRef);
            if (!roomDoc.exists()) return;
            const data = roomDoc.data();
            const players = Array.isArray(data.players) ? [...data.players] : [data.players['0'] || null, data.players['1'] || null];
            
            players[0] = {...players[0], bet: null, wantsRematch: false, rpsChoice: null};
            players[1] = {...players[1], bet: null, wantsRematch: false, rpsChoice: null};
            
            const nextTurn = data.roundWinner !== null && data.roundWinner !== -1 ? data.roundWinner : data.rpsWinner;
            
            transaction.update(roomRef, {
                players,
                status: 'betting',
                turn: nextTurn,
                rpsWinner: nextTurn,
                diceResult: null,
                roundWinner: null,
                diceFaces: null,
            });
        });
    }
}

// --- APP INITIALIZATION ---

enterLobbyBtn.addEventListener('click', () => {
    localPlayerName = playerNameInput.value.trim();
    if (!localPlayerName) {
        showNotification("Vui lòng nhập tên của bạn.", true);
        return;
    }
    localStorage.setItem('dice_player_name', localPlayerName);
    goToLobby();
});

(async () => {
    const savedName = localStorage.getItem('dice_player_name');
    if (savedName) {
        playerNameInput.value = savedName;
    }
    
    enterLobbyBtn.disabled = true;
    enterLobbyBtn.textContent = 'Đang kết nối...';
    enterLobbyBtn.classList.add('bg-gray-400', 'cursor-not-allowed');
    enterLobbyBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');

    onAuthStateChanged(auth, async (user) => {
        if (user) {
            userId = user.uid;
            enterLobbyBtn.disabled = false;
            enterLobbyBtn.textContent = 'Vào Sảnh Chờ';
            enterLobbyBtn.classList.remove('bg-gray-400', 'cursor-not-allowed');
            enterLobbyBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
        } else {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Authentication Error:", error);
                showNotification("Không thể kết nối. Vui lòng làm mới trang.", true);
                enterLobbyBtn.textContent = 'Lỗi kết nối';
            }
        }
    });
    
    showView(nameView);
})();
</script>
</body>
</html>
